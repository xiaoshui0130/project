看到很多小伙伴简历上写了“**熟练使用缓存**”，但是被我问到“**缓存常用的3种读写策略**”的时候却一脸懵逼。

在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。

但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！

下面我会简单介绍一下自己对于这 3 种缓存读写策略的理解。 

另外，**这3 种缓存读写策略各有优劣，不存在最佳，需要我们根据具体的业务场景选择更适合的。**

*个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！——爱你们的 Guide 哥*

### Cache Aside Pattern（==旁路缓存==模式）

**Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。**

Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。

下面我们来看一下这个策略模式下的缓存读写步骤。

**写** ：

- 先更新 DB
- 然后直接删除 cache 。

简单画了一张图帮助大家理解写的步骤。

![](https://img-blog.csdnimg.cn/img_convert/5687fe759a1dac9ed9554d27e3a23b6d.png)

**读** :

- 从 cache 中读取数据，读取到就直接返回
- cache中读取不到的话，就从 DB 中读取数据返回
- 再把数据放到 cache 中。

简单画了一张图帮助大家理解读的步骤。

![](https://img-blog.csdnimg.cn/img_convert/a8c18b5f5b1aed03234bcbbd8c173a87.png)


你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。

比如说面试官很可能会追问：“**在写数据的过程中，可以先删除 cache ，后更新 DB 么？**”

**答案：** 那肯定是不行的！因为这样可能会造成**数据库（DB）和缓存（Cache）数据不一致**的问题。为什么呢？比如说请求1 先写数据A，请求2随后读数据A的话就很有可能产生==数据不一致性==的问题。这个过程可以简单描述为：

> ==请求1先把cache中的A数据删除 -> 请求2从DB中读取数据->请求1再把DB中的A数据更新==。

当你这样回答之后，面试官可能会紧接着就追问：“**在写数据的过程中，先更新DB，后删除cache就没有问题了么？**”

**答案：** 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多！

比如请求1先读数据 A，请求2随后写数据A，并且==数据A不在缓存中的话也有可能产生数据不一致性的问题==。这个过程可以简单描述为：

> 请求1从DB读数据A->请求2写更新数据 A 到数据库并把删除cache中的A数据->请求1将数据A写入cache。

现在我们再来分析一下 **Cache Aside Pattern 的缺陷**。

**缺陷1：首次请求数据一定不在 cache 的问题** 

解决办法：可以将热点数据可以提前放入cache 中。

**缺陷2：写操作比较频繁的话导致cache中的数据会被频繁被删除，这样会影响缓存命中率 。**

解决办法：

- 数据库和缓存数据强一致场景 ：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来==保证更新cache的时候不存在线程安全问题==。
- 可以短暂地允许数据库和缓存数据不一致的场景 ：更新DB的时候同样更新cache，但是给缓存==加一个比较短的过期时间==，这样的话就可以保证即使数据不一致的话影响也比较小。

### Read/Write Through Pattern（==读写穿透==）

Read/Write Through Pattern 中==服务端把 cache 视为主要数据存储==，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 DB，从而减轻了应用程序的职责。

这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的==分布式缓存 Redis 并没有提供 cache 将数据写入DB的功能==。

**写（Write Through）：**

- 先查 cache，cache 中不存在，直接更新 DB。
- cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（**同步更新 cache 和 DB**）。

简单画了一张图帮助大家理解写的步骤。

![](https://img-blog.csdnimg.cn/20210201100340808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70)

**读(Read Through)：** 

- 从 cache 中读取数据，读取到就直接返回 。
- 读取不到的话，先从 DB 加载，写入到 cache 后返回响应。

简单画了一张图帮助大家理解读的步骤。

![](https://img-blog.csdnimg.cn/img_convert/9ada757c78614934aca11306f334638d.png)

Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由==客户端自己==负责把数据写入 cache，而 Read Through Pattern 则是 ==cache 服务自己来写入缓存==的，这==对客户端是透明==的。

和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。

### Write Behind Pattern（==异步缓存写入==）

Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。

但是，两个又有很大的不同：**==Read/Write Through 是同步更新 cache 和 DB==，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为==异步批量==的方式来更新 DB。**

很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。

这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如==消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制==都用到了这种策略。

Write Behind Pattern 下 ==DB 的写性能非常高==，非常适合一些数据经常变化又对==数据一致性要求没那么高的场景，比如浏览量、点赞量。==









https://liuyj.top/2021/03/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARedis(%E4%B8%80)%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%89%E7%A7%8D%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F/



## 前言

我们在实际的项目中经常会使用到缓存，本文我们主要来总结下缓存的几种常见的读写模式。

## 缓存的读写模式

### Cache Aside Pattern（常用）

Cache Aside Pattern（旁路缓存），是最经典的缓存+数据库读写模式。 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

[![img](https://img.liuyj.top/image-20210308153152098.png)](https://img.liuyj.top/image-20210308153152098.png)

更新的时候，先更新数据库，然后再删除缓存 。

[![img](https://img.liuyj.top/image-20210308153239381.png)](https://img.liuyj.top/image-20210308153239381.png)

**==为什么是删除缓存，而不是更新缓存呢==**？

原因有两点：

1. 如果缓存的结构是一个hash或list等，更新数据时需要遍历，比较耗时
2. 我们对于缓存的要求是懒加载，也就是使用的时候才更新即可。我们可以采用异步的方式填充缓存，比如开启一个线程，定时将DB（数据库）中的数据刷到缓存中去。

**高并发脏读的三种情况** 1、先==更新数据库，再更新缓存 update与commit之间，更新缓存，commit失败 则DB与缓存数据不一致。==

再举一例：

> 1、A更新数据库

> 2、B更新数据库

> 3、B写入缓存

> 4、A写入缓存

本来最终结果应该是B写入缓存才对，而由于网络延迟等原因，导致A与B写入缓存的顺序颠倒，造成数据不一致。

2、先删除缓存，再更新数据库 update与commit之间，有新的读，缓存空，读DB数据到缓存 数据是旧的数据 commit后 DB为新数据 则DB与缓存数据不一致 3、先更新数据库，再删除缓存（推荐） update与commit之间，有新的读，缓存空，读DB数据到缓存 数据是旧的数据 commit后 DB为新数据 则DB与缓存数据不一致 解决方法：采用**延时双删**策略

**延时双删**：

为什么采用延时双删？

1. 假如只先删缓存，会出现在第一个事务更新数据库之前，另一个事务又将旧数据放入缓存的问题，如下图所示：（事务B应该为查询数据库而不是清空缓存）

[![img](https://img.liuyj.top/image-20210309095726117.png)](https://img.liuyj.top/image-20210309095726117.png)

1. 假如只后删缓存，那么在更新完数据库之后、更新缓存之前的这段时间内，其他事务的查询都拿到的是旧数据，如下图所示：

[![img](https://img.liuyj.top/image-20210309101009500.png)](https://img.liuyj.top/image-20210309101009500.png)

1. 普通双删

存在的问题：第一次清空缓存后，更新数据库前的这段时间内，其他事务查询了数据库的数据，第二次清空缓存后，刚才查询数据库 的那个线程又更新了缓存，此时又会将旧数据更新到缓存。

如下图所示：

[![img](https://img.liuyj.top/image-20210309141557606.png)](https://img.liuyj.top/image-20210309141557606.png)

1. 延时双删

在3中，第二次清空缓存之前，多延时一会，等B更新缓存结束了，再删除缓存，这样缓存就不存在了，其他事务查到的就是新缓存。

延时操作是为了确保 修改数据库——>清空缓存前，这段时间内，其他事务的更新缓存操作已完成。

[![img](https://img.liuyj.top/%E5%BB%B6%E6%97%B6%E5%88%A0.jpg)](https://img.liuyj.top/延时删.jpg)

采用延时删最后一次缓存，但这其中难免还是会大量的查询到旧缓存数据的，如下图所示：

[![img](https://img.liuyj.top/%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0.jpg)](https://img.liuyj.top/延时双删.jpg)

这时候可以通过加锁来解决，一次性不让太多的线程都来请求，另外从图上看，我们可以尽量缩短**第一次删除缓存和更新数据库**的时间差，这样可以使得其他事务第一时间获取到更新数据库后的数据。

### Read/Write Through Pattern

**Read-Through**（穿透读模式/直读模式）：应用程序读缓存，缓存没有，由缓存回源到数据库，并写入 缓存。（guavacache采用此种方式）

**Write-Through**（穿透写模式/直写模式）：应用程序写缓存，缓存写数据库。

该种模式需要提供数据库的handler，开发较为复杂。

### Write Behind Caching Pattern

描述：应用程序只更新缓存。缓存通过异步的方式将数据批量或合并后更新到DB中 存在的问题：不能时时同步，甚至会丢数据

## 总结

本文主要学习了缓存的几种读写模式，常用的旁路缓存模式，重点研究了延时双删的策略来减少访问缓存出现的问题。
